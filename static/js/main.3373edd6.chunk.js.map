{"version":3,"sources":["components/generalStyles/buttons.module.scss","components/exercises/exercises.module.scss","components/proofEditor/proofEditor.module.scss","components/examples/singleExampleDisplay.module.scss","components/navigationBar/navigationBar.module.scss","components/generalStyles/pageLayout.module.scss","components/examples/navigatableExamples.module.scss","components/mainPage/mainPage.tsx","components/navigationBar/navigationBar.tsx","components/contact/contact.tsx","components/errorPage404/errorPage404.tsx","components/examples/singleExampleDisplay.tsx","components/examples/navigatableExamples.tsx","components/propositionalLogic/examplePage.tsx","util/issueHandling/issueMapping.ts","util/inputFormatter/regexes.ts","util/inputFormatter/expressionFormatter.ts","util/inputFormatter/textFormatter.ts","util/vocabularyChecker/detectWrongSyntax.ts","util/vocabularyChecker/iterators.ts","util/diproche/diprocheInterface.ts","util/diproche/diprocheResponseProcessing.ts","util/proofChecker.ts","components/proofEditor/issuePositionInformation.tsx","components/proofEditor/issueInformation.tsx","components/proofEditor/proofEditor.tsx","components/exercises/exercises.tsx","components/propositionalLogic/exercises.tsx","components/propositionalLogic/sandbox.tsx","components/propositionalLogic/wiki.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","buttons","selector","preText","postText","toggleExerciseSolutionBtn","checkProofBtn","proofEditor","textInput","textInputFalse","IssuePositionInformation","successMessage","clickToChange","alreadyClicked","headline","pageContent","exampleChanger","ProofEditor","react_default","a","createElement","React","Component","Navigation","className","styles","navigationBar","react_router_dom","to","Kontakt","ErrorPage404","initializeShowExplanation","example","Array","length","fill","SingleExampleDisplay","props","_this","Object","classCallCheck","this","showExplanation","possibleConstructorReturn","getPrototypeOf","call","exampleData","state","setState","site","renderProof","_this2","renderedPart","push","forEach","line","index","explanation","scssClass","onClick","Fragment","copy","NavigatableExamples","exampleToShow","renderExampleButtons","singleExampleDisplay","examplesData","_","buttonStyles","ExamplePage","navigatableExamples","data","examples","addIssue","issueCode","position","replacements","issue","objectSpread","issueJson","code","message","replace","PLACEHOLDER_PATTERN","placeholder","name","replacement","undefined","toString","insertReplacementsForPlaceholders","foundIssues","addIssueToIssueList","emptyIssueList","listAllIssues","Regexes","inputSeparator","RegExp","expressionSeparator","annotationMarker","expressionMarker","endProofMarker","wordSeparator","wordMarker","whiteSpace","allWhiteSpace","bracketLeft","bracketRight","equivalence","implicationRight","implicationLeft","negation","conjunction","disjunction","equal","addition","subtraction","division","multiplication","wordEndsWithComma","orRegex","_len","arguments","regexes","_key","map","r","source","join","bracket","implication","logicConnector","functionalConnector","allowedExpressionToken","expressionFormatter","expression","expressionPosition","preFormattedExpression","split","filter","x","preFormatExpressionFromImput","bracketCount","fromPos","toPos","isEmpty","element","match","fromIndex","toIndex","detectBracketIssues","foundConnector","foundStatement","foundNegation","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","Symbol","iterator","next","done","value","test","i","temp","char","charAt","err","return","detectMissingStatementsOrConnector","expressionIssueDetector","finalFormattedExpression","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","trim","replaceASingleExpressionElementIntoPrologCode","replaceExpressionElementsIntoPrologCode","finalFormattedExpressionString","slice","preformattedExpressionElement","textFormatter","input","splittedSentence","formattedText","formattedSentence","splittedElement","innerElement","formattedExpression","ListOfWords","sentenceIntoWordList","output","toLowerCase","formattedTextIntoString","splittedSentenceIntoListOfWords","listOfWords","splice","listOfWordsString","anyWord","allowedWords","json","collectInvalidWordsInIssues","text","invalidWords","from","values","Set","removeDuplicates","word","includes","collectAllInvalidWords","getInvalidWords","allPositionsOfInvalidWord","getPositionsOfInvalidWord","invalidWord","foundIndex","result","offSet","indexOf","Mode","addDiprocheIssues","diprocheResponse","listAsString","stringCopy","outterForm","jsArray","innerString","innerArray","parseInt","convertErrorListStringToJSArray","ErrorList","exec","getErrorList","unverifiedLine","getSyntacticErrors","userInput","getVocabErrors","getErrorsAfterDiproche","_x","_getErrorsAfterDiproche","apply","_callee","diprocheInput","regenerator_default","wrap","_context","prev","getDiprocheResponse","sent","stop","createErrors","_x2","_createErrors","_callee2","userinput","_context2","severities","checkProof","_checkProof","curatedUserInput","abrupt","orderIssuesBySeverity","_getDiprocheResponse","body","response","responseText","fetch","headers","Content-Type","method","issues","orderedIssues","severity","concat","singleIssue","_React$Component","inherits","createClass","key","IssueInformation","displayedPosition","issuePositionInformation","shortid","generate","checkInput","asyncToGenerator","mark","transformUserinputPreCheck","setStateParent","required","onChange","ev","target","renderAfterInputFieldText","issuesInformation","renderIssueList","displayAfterInputfield","exerciseStyles","issueList","issueInformation","Exercises","exerciseID","showSolution","event","selectorOnChangeHandler","renderExerciseOptions","renderExerciseOrSolution","renderToggleButton","Number","_this3","exampleSolution","activeExercise","start","insert","addStartAndEndToUserInput","end","_this4","buttonCaption","options","oneExercise","title","exercises","exerciseData","Sandbox","WikiPropositionalLogic","App","react_router","exact","path","component","MainPage","ExamplesPropositionalLogic","ExercisesPropositionalLogic","SandboxPropositionalLogic","Boolean","window","location","hostname","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3373edd6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"buttons\":\"buttons_buttons__2CdZP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selector\":\"exercises_selector__1Gkxl\",\"preText\":\"exercises_preText__1qxK_\",\"postText\":\"exercises_postText__27ooK\",\"toggleExerciseSolutionBtn\":\"exercises_toggleExerciseSolutionBtn__5cUsU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"checkProofBtn\":\"proofEditor_checkProofBtn__145QR\",\"proofEditor\":\"proofEditor_proofEditor__Nelof\",\"textInput\":\"proofEditor_textInput__nhHsN\",\"textInputFalse\":\"proofEditor_textInputFalse__3UNBC\",\"IssuePositionInformation\":\"proofEditor_IssuePositionInformation__GMYyt\",\"successMessage\":\"proofEditor_successMessage__1PpX4\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"clickToChange\":\"singleExampleDisplay_clickToChange__4ZH1a\",\"alreadyClicked\":\"singleExampleDisplay_alreadyClicked__2Bmoh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"headline\":\"navigationBar_headline__2VjDT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"pageContent\":\"pageLayout_pageContent__1u1fq\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"exampleChanger\":\"navigatableExamples_exampleChanger__2k6wK\"};","import React from \"react\";\r\n\r\nclass ProofEditor extends React.Component {\r\n\r\n\tpublic render() {\r\n\t\treturn <div>\r\n\t\t\t<h1>Willkommen bei Diproche!</h1>\r\n\t\t\t<p>\r\n\t\t\t\t<b>Diproche</b> steht für <b>Didactical proof checking</b>. Das heißt im Wesentlichen, dass Diproche die\r\n\t\t\t\tMöglichkeit bietet, Beweise auf ihre Richtigkeit zu überprüfen. Dafür müssen die Beweise auf eine\r\n\t\t\t\tbestimmte Art aufgeschrieben werden. Wie man das macht, kann man in der Kategorie <b>Beispiele</b> sehen.\r\n\t\t\t\tUnter <b>Übungen</b> gibt es vorgefertigte Aufgabenstellungen, die man durch\r\n\t\t\t\teinen Beweis lösen soll. Will man eine eigene Aussage formulieren und beweisen,\r\n\t\t\t\tkann man die Kategorie <b>Freies Üben</b> dafür nutzen. Wenn man noch nicht\r\n\t\t\t\tallzu vertraut mit der Theorie hinter dem ist, was man beweisen möchte, findet\r\n\t\t\t\tman im <b>Wiki</b> einige Informationen dazu. Bei Problemen befinden sich unter <b>Kontakt</b> die\r\n\t\t\t\tpassenden Ansprechpartner. Viel Spaß beim Beweisen!\r\n\t\t\t</p>\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ProofEditor;\r\n","import React from \"react\";\r\nimport { NavLink } from \"react-router-dom\";\r\nimport styles from \"./navigationBar.module.scss\";\r\n\r\nconst Navigation = () => {\r\n\r\n\treturn (<div className={styles.navigationBar}>\r\n\t\t<ul className={styles.headline}>\r\n\t\t\t<li><NavLink to=\"/\">Startseite</NavLink></li>\r\n\t\t\t<li><NavLink to=\"/examples\">Beispiele</NavLink></li>\r\n\t\t\t<li><NavLink to=\"/exercises\">Übungen</NavLink></li>\r\n\t\t\t<li><NavLink to=\"/sandbox\">Freies Üben</NavLink></li>\r\n\t\t\t<li><NavLink to=\"/wiki\">Wiki</NavLink></li>\r\n\t\t\t<li><NavLink to=\"/contact\">Kontakt</NavLink></li>\r\n\t\t</ul>\r\n\t</div >);\r\n};\r\n\r\nexport default Navigation;\r\n","import React from \"react\";\r\n\r\nclass Kontakt extends React.Component<{}, {}> {\r\n\tpublic render() {\r\n\r\n\t\treturn <div>\r\n\t\t\tKontakt\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default Kontakt;\r\n","import React from \"react\";\r\n\r\nconst ErrorPage404 = () => {\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<p>404 Page Not Found</p>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nexport default ErrorPage404;\r\n","import React from \"react\";\r\nimport styles from \"./singleExampleDisplay.module.scss\";\r\n\r\ninterface IProps {\r\n\texampleData: string[][];\r\n}\r\n\r\ninterface IState {\r\n\tshowExplanation: boolean[];\r\n}\r\n\r\nclass SingleExampleDisplay extends React.Component<IProps, IState> {\r\n\r\n\t// Via constructor since an immediate assignment led to type issues\r\n\tconstructor(props: IProps) {\r\n\t\tsuper(props);\r\n\t\tconst showExplanation = initializeShowExplanation(this.props.exampleData);\r\n\t\tthis.state = { showExplanation };\r\n\t}\r\n\r\n\tpublic componentWillReceiveProps() {\r\n\t\tconst showExplanation = initializeShowExplanation(this.props.exampleData);\r\n\t\tthis.setState({ showExplanation });\r\n\t}\r\n\r\n\tpublic render() {\r\n\t\treturn <div className={styles.site}>\r\n\t\t\t<table className={styles.example}>\r\n\t\t\t\t{this.renderProof()}\r\n\t\t\t</table>\r\n\t\t</div >;\r\n\t}\r\n\r\n\tprivate renderProof(): JSX.Element {\r\n\t\tconst renderedPart: JSX.Element[] = [];\r\n\r\n\t\trenderedPart.push(<tr>\r\n\t\t\t\t<th>Eingabe</th>\r\n\t\t\t\t<th>Klicke auf \"Hilfe\", um eine Erklärung anzeigen zu lassen.</th>\r\n\t\t</tr>);\r\n\r\n\t\trenderedPart.push(<tr>\r\n\t\t\t<td></td>\r\n\t\t\t<td></td>\r\n\t\t</tr>);\r\n\r\n\t\tconst proofPart: string[][] = this.props.exampleData;\r\n\r\n\t\tproofPart.forEach((line: string[], index: number) => {\r\n\t\t\tlet explanation: string;\r\n\t\t\tlet scssClass: string;\r\n\r\n\t\t\tif (this.state.showExplanation[index]) {\r\n\t\t\t\texplanation = line[1];\r\n\t\t\t\tscssClass = styles.alreadyClicked;\r\n\t\t\t} else {\r\n\t\t\t\texplanation = \"Hilfe\";\r\n\t\t\t\tscssClass = styles.clickToChange;\r\n\t\t\t}\r\n\t\t\trenderedPart.push(<tr>\r\n\t\t\t\t<td>{line[0]}</td>\r\n\t\t\t\t<td className={scssClass} onClick={() => this.showExplanation(index)}>{explanation}</td>\r\n\t\t\t</tr>);\r\n\t\t});\r\n\r\n\t\treturn <React.Fragment>\r\n\t\t\t{renderedPart}\r\n\t\t</React.Fragment>;\r\n\t}\r\n\r\n\tprivate showExplanation(index: number): void {\r\n\t\tconst copy: boolean[] = this.state.showExplanation;\r\n\t\tcopy[index] = true;\r\n\t\tthis.setState({showExplanation: copy});\r\n\t}\r\n\r\n}\r\n\r\nfunction initializeShowExplanation(example: string[][]): boolean[] {\r\n\treturn Array(example.length).fill(false);\r\n}\r\n\r\nexport default SingleExampleDisplay;\r\n","import React from \"react\";\r\nimport buttonStyles from \"../generalStyles/buttons.module.scss\";\r\nimport styles from \"./navigatableExamples.module.scss\";\r\nimport SingleExampleDisplay from \"./singleExampleDisplay\";\r\n\r\ninterface IProps {\r\n\texamplesData: string[][][];\r\n}\r\n\r\ninterface IState {\r\n\texampleToShow: number;\r\n}\r\n\r\nclass NavigatableExamples extends React.Component<IProps, IState> {\r\n\r\n\tpublic state: IState = {\r\n\t\texampleToShow: 0,\r\n\t};\r\n\r\n\tpublic render() {\r\n\t\treturn <React.Fragment>\r\n\t\t\t{this.renderExampleButtons()}\r\n\t\t\t<SingleExampleDisplay\r\n\t\t\t\texampleData={this.props.examplesData[this.state.exampleToShow]}\r\n\t\t\t/>\r\n\t\t</React.Fragment>;\r\n\t}\r\n\r\n\tprivate renderExampleButtons(): JSX.Element[] {\r\n\r\n\t\tconst buttons: JSX.Element[] = [];\r\n\t\tthis.props.examplesData.forEach((_, index: number) => {\r\n\t\t\tbuttons.push(\r\n\t\t\t\t<button className={buttonStyles.buttons + \" \" + styles.exampleChanger}\r\n\t\t\t\t\tonClick={() => this.setState({exampleToShow: index})}>\r\n\t\t\t\t\tBeispiel {index + 1}\r\n\t\t\t\t</button>);\r\n\t\t});\r\n\r\n\t\treturn buttons;\r\n\t}\r\n\r\n}\r\n\r\nexport default NavigatableExamples;\r\n","import React from \"react\";\r\nimport NavigatableExamples from \"../examples/navigatableExamples\";\r\nimport data from \"./examples.json\";\r\n\r\nclass ExamplePage extends React.Component< {} , {} > {\r\n\tpublic render() {\r\n\t\treturn <React.Fragment>\r\n\t\t\t<NavigatableExamples\r\n\t\t\t\texamplesData = { data.examples }\r\n\t\t\t/>\r\n\t\t</React.Fragment>;\r\n\t}\r\n\r\n}\r\n\r\nexport default ExamplePage;\r\n","import Issue from \"./issue\";\r\nimport issueJson from \"./knownIssues.json\";\r\nimport Position from \"./position\";\r\n\r\n/** All the valid issue-codes */\r\nexport type IssueCode = keyof typeof issueJson;\r\n\r\ninterface ReplacementMap {\r\n\t[placeholder: string]: string | number;\r\n}\r\n\r\n/**\r\n * This function needs to be called when someone wants to store a known issue;\r\n * @param issueJson the issueobject that should be stored in the issuelist.\r\n * @param addPosition optional position where issue is located;\r\n * @param replacements optional replacements for the placeholders in the issue message.\r\n */\r\nexport function addIssue(\r\n\tissueCode: IssueCode,\r\n\tposition?: Position,\r\n\treplacements?: ReplacementMap) {\r\n\tconst issue: Issue = {\r\n\t\t...issueJson[issueCode],\r\n\t\tcode: issueCode,\r\n\t\tposition,\r\n\t};\r\n\tif (replacements) {\r\n\t\tissue.message = insertReplacementsForPlaceholders(issue.message, replacements);\r\n\t}\r\n\r\n\taddIssueToIssueList(issue);\r\n}\r\n\r\nconst PLACEHOLDER_PATTERN = /{([A-Za-z0-9]+)}/g;\r\n\r\nfunction insertReplacementsForPlaceholders(message: string, replacements: ReplacementMap): string {\r\n\treturn message.replace(PLACEHOLDER_PATTERN, (placeholder, name) => {\r\n\t\tconst replacement = replacements[name];\r\n\t\tif (replacement === undefined) {\r\n\t\t\treturn placeholder;\r\n\t\t} else {\r\n\t\t\treturn replacement.toString();\r\n\t\t}\r\n\t});\r\n}\r\n\r\nlet foundIssues: Issue[] = [];\r\n\r\n/**\r\n * empty the list of issues\r\n */\r\nexport function emptyIssueList() {\r\n\tfoundIssues = [];\r\n}\r\n\r\n/**\r\n * this method is called by the addIssue function\r\n * @param issue that is added to the issuelist\r\n */\r\nexport function addIssueToIssueList(issue: Issue) {\r\n\tfoundIssues.push(issue);\r\n}\r\n\r\n/**\r\n * list all the found issues\r\n * @return all found issues\r\n */\r\nexport function listAllIssues(): ReadonlyArray<Issue> {\r\n\treturn foundIssues;\r\n}\r\n","export const Regexes = {\r\n\tinputSeparator: new RegExp(/(=>|<=|\\!|\\.|\\?|\\n)/, \"ig\"),\r\n\texpressionSeparator: new RegExp(/(\\$[^$]*[\\$])/, \"ig\"),\r\n\tannotationMarker: new RegExp(/(=>|<=)/, \"ig\"),\r\n\texpressionMarker: new RegExp(/\\$/, \"ig\"),\r\n\tendProofMarker: new RegExp(/qed/, \"ig\"),\r\n\twordSeparator: new RegExp(/[ ,]+/, \"ig\"),\r\n\twordMarker: new RegExp(/([A-Za-zäöüß]+)/, \"ig\"),\r\n\twhiteSpace: new RegExp(/\\s/, \"ig\"),\r\n\tallWhiteSpace: new RegExp(/\\s+/, \"ig\"),\r\n\tbracketLeft: new RegExp(/(\\[|\\(|bracketLeft)/, \"ig\"),\r\n\tbracketRight: new RegExp(/(\\]|\\)|bracketRight)/, \"ig\"),\r\n\tequivalence: new RegExp(/(<-->|<==>|<=>|<->|equivalence)/, \"ig\"),\r\n\timplicationRight: new RegExp(/(->|-->|\\\\rightarrow|implicationRight)/, \"ig\"),\r\n\timplicationLeft: new RegExp(/(<-|<--|\\/leftarrow|implicationLeft)/, \"ig\"),\r\n\tnegation: new RegExp(/(neq|not|nicht|¬|neg)/, \"ig\"),\r\n\tconjunction: new RegExp(/(and|und|&|\\/\\\\|conjunction)/, \"ig\"),\r\n\tdisjunction: new RegExp(/(or|oder|\\||\\\\\\/|disjunction)/, \"ig\"),\r\n\tequal: new RegExp(/(=|==|===|gleich|equal)/, \"ig\"),\r\n\taddition: new RegExp(/(\\+|plus|add|sum)/, \"ig\"),\r\n\tsubtraction: new RegExp(/(-|minus)/, \"ig\"),\r\n\tdivision: new RegExp(/(:|\\/|div|geteilt)/, \"ig\"),\r\n\tmultiplication: new RegExp(/(\\*|mal|mult)/, \"ig\"),\r\n\twordEndsWithComma: new RegExp(/^(.+),$/, \"ig\"),\r\n};\r\n\r\nexport const orRegex = (...regexes: RegExp[]) =>\r\n\tnew RegExp(regexes.map(r => r.source).join(\"|\"));\r\n\r\nexport const bracket = new RegExp(orRegex(\r\n\tRegexes.bracketLeft,\r\n\tRegexes.bracketRight,\r\n), \"ig\");\r\n\r\nexport const implication = new RegExp(orRegex(\r\n\tRegexes.implicationRight,\r\n\tRegexes.implicationLeft,\r\n), \"ig\");\r\nexport const logicConnector = new RegExp(orRegex(\r\n\tRegexes.conjunction,\r\n\tRegexes.disjunction,\r\n\tRegexes.equivalence,\r\n\timplication,\r\n), \"ig\");\r\nexport const functionalConnector = new RegExp(orRegex(\r\n\tRegexes.equal,\r\n\tRegexes.addition,\r\n\tRegexes.subtraction,\r\n\tRegexes.multiplication,\r\n\tRegexes.division,\r\n), \"ig\");\r\n\r\nexport const allowedExpressionToken = new RegExp(orRegex(\r\n\tRegexes.expressionMarker,\r\n\tbracket,\r\n\tRegexes.equivalence,\r\n\timplication,\r\n\tRegexes.negation,\r\n\tRegexes.conjunction,\r\n\tRegexes.disjunction,\r\n\tfunctionalConnector,\r\n), \"ig\");\r\n","import { addIssue } from \"../issueHandling/issueMapping\";\r\nimport { allowedExpressionToken, bracket, logicConnector, Regexes } from \"./regexes\";\r\n\r\n/**\r\n * main method to format expressions\r\n * @param expression written by user\r\n * @return a formatted expression as string[];\r\n * each element of the expression gets formatted into prolog readable code\r\n */\r\nexport function expressionFormatter(expression: string, expressionPosition: number): string {\r\n\tconst preFormattedExpression: string[] = preFormatExpressionFromImput(expression);\r\n\texpressionIssueDetector(preFormattedExpression, expressionPosition);\r\n\tconst finalFormattedExpression: string[] = replaceExpressionElementsIntoPrologCode(preFormattedExpression);\r\n\tlet finalFormattedExpressionString = \"[\";\r\n\tfinalFormattedExpression.forEach(element => {\r\n\t\tif (element.match(Regexes.bracketLeft)) {\r\n\t\t\tfinalFormattedExpressionString = finalFormattedExpressionString + element;\r\n\t\t} else if (element.match(Regexes.bracketRight)) {\r\n\t\t\tfinalFormattedExpressionString = finalFormattedExpressionString.slice(0, finalFormattedExpressionString.length - 1);\r\n\t\t\tfinalFormattedExpressionString = finalFormattedExpressionString + element + \",\";\r\n\t\t} else {\r\n\t\t\tfinalFormattedExpressionString = finalFormattedExpressionString + element + \",\";\r\n\t\t}\r\n\r\n\t});\r\n\tif (finalFormattedExpressionString.match(Regexes.wordEndsWithComma)) {\r\n\t\tfinalFormattedExpressionString = finalFormattedExpressionString.slice(0, finalFormattedExpressionString.length - 1);\r\n\t}\r\n\tfinalFormattedExpressionString = finalFormattedExpressionString + \"]\";\r\n\treturn finalFormattedExpressionString;\r\n}\r\n\r\n/**\r\n *  * Returns a preformatted expression where some different\r\n * input styles for logical vocabulary gets formatted into one single style\r\n * @param expression written by user\r\n */\r\nexport function preFormatExpressionFromImput(expression: string): string[] {\r\n\tconst splittedExpression: string[] = expression.split(allowedExpressionToken);\r\n\tconst filtered = splittedExpression.filter(x => x);\r\n\treturn filtered;\r\n}\r\n\r\n/**\r\n * Returns finalExpression where expression elements got replaced with readable prolog code elements\r\n */\r\nexport function replaceExpressionElementsIntoPrologCode(preFormattedExpression: string[]): string[] {\r\n\tconst finalFormattedExpression: string[] = [];\r\n\tfor (let element of preFormattedExpression) {\r\n\t\telement = element.trim();\r\n\t\tif (element.match(allowedExpressionToken)) {\r\n\t\t\telement = replaceASingleExpressionElementIntoPrologCode(element).trim();\r\n\t\t\tfinalFormattedExpression.push(element);\r\n\t\t} else {\r\n\t\t\telement = element.trim();\r\n\t\t\telement = element.replace(Regexes.allWhiteSpace, \" \");\r\n\t\t\tfinalFormattedExpression.push(element);\r\n\t\t}\r\n\t}\r\n\tconst filtered = finalFormattedExpression.filter(x => x);\r\n\treturn filtered;\r\n}\r\n\r\n/**\r\n * helper function for replaceExpressionElementsIntoPrologCode\r\n * @return finalExpressionElement\r\n */\r\nexport function replaceASingleExpressionElementIntoPrologCode(preformattedExpressionElement: string): string {\r\n\tconst finalExpression: string = preformattedExpressionElement;\r\n\treturn finalExpression\r\n\t\t.replace(Regexes.expressionMarker, \"\")\r\n\t\t.replace(Regexes.whiteSpace, \"\")\r\n\t\t.replace(Regexes.bracketLeft, \"\\[\")\r\n\t\t.replace(Regexes.bracketRight, \"\\]\")\r\n\t\t.replace(Regexes.equivalence, \"<->\")\r\n\t\t.replace(Regexes.implicationRight, \"->\")\r\n\t\t.replace(Regexes.implicationLeft, \"<-\")\r\n\t\t.replace(Regexes.negation, \"neg\")\r\n\t\t.replace(Regexes.conjunction, \"and\")\r\n\t\t.replace(Regexes.disjunction, \"or\")\r\n\t\t.replace(Regexes.equal, \"=\")\r\n\t\t.replace(Regexes.addition, \"+\")\r\n\t\t.replace(Regexes.subtraction, \"-\")\r\n\t\t.replace(Regexes.multiplication, \"*\")\r\n\t\t.replace(Regexes.division, \":\")\r\n\t\t;\r\n}\r\n\r\n/**\r\n * Detects issues with an expression\r\n */\r\nexport function expressionIssueDetector(preFormattedExpression: string[], expressionPosition: number) {\r\n\tdetectBracketIssues(preFormattedExpression, expressionPosition);\r\n\tdetectMissingStatementsOrConnector(preFormattedExpression, expressionPosition);\r\n}\r\n\r\n/**\r\n * Check the expression for an equal amount of opened and closed brackets.; it can detect wrong input\r\n */\r\nexport function detectBracketIssues(expression: string[], expressionPosition: number) {\r\n\tlet bracketCount: number = 0;\r\n\tlet fromPos: number = expressionPosition;\r\n\tlet toPos: number = expressionPosition;\r\n\tlet isEmpty: boolean = true;\r\n\texpression.forEach(element => {\r\n\t\ttoPos = fromPos + element.length;\r\n\t\tif (element.match(Regexes.bracketLeft)) {\r\n\t\t\tbracketCount++;\r\n\t\t\tisEmpty = true;\r\n\t\t} else if (element.match(Regexes.bracketRight)) {\r\n\t\t\tbracketCount--;\r\n\t\t\tif (isEmpty === true) {\r\n\t\t\t\taddIssue(\"EMPTY_BRACKET\", { fromIndex: fromPos, toIndex: fromPos });\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tisEmpty = false;\r\n\t\t}\r\n\t\tif (bracketCount < 0) {\r\n\t\t\taddIssue(\"BRACKET_OVERCLOSING\", { fromIndex: fromPos, toIndex: fromPos + element.length });\r\n\t\t\tbracketCount = 0;\r\n\t\t}\r\n\t\tfromPos = toPos;\r\n\t});\r\n\tif (bracketCount > 0) {\r\n\t\taddIssue(\"BRACKET_UNDERCLOSING\");\r\n\t}\r\n}\r\n\r\n/**\r\n * check the expression for correctness that no logic operators or statements is forgotten; it can detect wrong input\r\n */\r\nexport function detectMissingStatementsOrConnector(expression: string[], expressionPosition: number) {\r\n\tlet foundConnector: boolean = true;\r\n\tlet foundStatement: boolean = false;\r\n\tlet foundNegation: boolean = false;\r\n\tlet fromPos: number = expressionPosition;\r\n\tfor (const element of expression) {\r\n\t\tif (/\\S/.test(element)) {\r\n\t\t\tif (element.match(bracket)) {\r\n\t\t\t\tif (element.match(Regexes.bracketRight) &&\r\n\t\t\t\t\tfoundStatement === false && (foundConnector === true || foundNegation === true)) {\r\n\t\t\t\t\taddIssue(\"MISSING_STATEMENT_INSIDE\", { fromIndex: fromPos, toIndex: fromPos });\r\n\t\t\t\t}\r\n\t\t\t\tfromPos = fromPos + element.length;\r\n\t\t\t} else if (element.match(Regexes.negation)) {\r\n\t\t\t\tfoundNegation = true;\r\n\t\t\t\tfoundConnector = false;\r\n\t\t\t\tfoundStatement = false;\r\n\t\t\t\tfromPos = fromPos + element.length;\r\n\t\t\t} else if (element.match(logicConnector)) {\r\n\t\t\t\tif (foundNegation === true) {\r\n\t\t\t\t\taddIssue(\"MISSING_STATEMENT_AFTER_NEGATION\", { fromIndex: fromPos, toIndex: fromPos });\r\n\t\t\t\t} else if (foundConnector === true || element.match(Regexes.bracketLeft)) {\r\n\t\t\t\t\taddIssue(\"MISSING_STATEMENT_INSIDE\", { fromIndex: fromPos, toIndex: fromPos });\r\n\t\t\t\t}\r\n\t\t\t\tfromPos = fromPos + element.length;\r\n\t\t\t\tfoundConnector = true;\r\n\t\t\t\tfoundStatement = false;\r\n\t\t\t\tfoundNegation = false;\r\n\t\t\t} else {\r\n\t\t\t\tlet i;\r\n\t\t\t\tlet temp = 0;\r\n\t\t\t\tfor (i = 0; i < element.length; i++) {\r\n\t\t\t\t\tconst char = element.charAt(i);\r\n\t\t\t\t\tif (char.match(Regexes.whiteSpace)) {\r\n\t\t\t\t\t\ttemp++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (foundStatement === true && temp > 0) {\r\n\t\t\t\t\t\t\taddIssue(\"MISSING_CONNECTOR\", { fromIndex: fromPos, toIndex: fromPos + temp });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfoundConnector = false;\r\n\t\t\t\t\t\tfoundStatement = true;\r\n\t\t\t\t\t\tfoundNegation = false;\r\n\t\t\t\t\t\tfromPos = fromPos + temp + 1;\r\n\t\t\t\t\t\ttemp = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfromPos = fromPos + temp;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfromPos = fromPos + element.length;\r\n\t\t}\r\n\r\n\t}\r\n\tif (foundStatement === false && (foundConnector === true || foundNegation === true)) {\r\n\t\taddIssue(\"MISSING_STATEMENT_INSIDE\", { fromIndex: fromPos, toIndex: fromPos });\r\n\t}\r\n}\r\n","import { expressionFormatter } from \"./expressionFormatter\";\r\nimport { Regexes } from \"./regexes\";\r\n\r\n/**\r\n * this functions is the main function to format the full input string\r\n * into a Array of string[]\r\n * @param input from user\r\n * @return the formatted text as a Array of string[] inculding\r\n * formatted expressions and list of words (setences)\r\n */\r\nexport function textFormatter(input: string): string {\r\n\tlet splittedSentence: string[] = input.split(Regexes.inputSeparator);\r\n\tsplittedSentence = splittedSentence.filter(x => x);\r\n\tconst formattedText: string[][] = [];\r\n\tlet position: number = 0;\r\n\tsplittedSentence.forEach(element => {\r\n\t\tif (element.match(Regexes.annotationMarker)) {\r\n\t\t\tformattedText.push([element]);\r\n\t\t} else if (element.match(Regexes.expressionMarker)) {\r\n\t\t\tlet formattedSentence: string = \"\";\r\n\t\t\tlet splittedElement: string[] = element.split(Regexes.expressionSeparator);\r\n\t\t\tsplittedElement = splittedElement.filter(x => x);\r\n\t\t\tsplittedElement.forEach(innerElement => {\r\n\t\t\t\tif (innerElement.match(Regexes.expressionMarker)) {\r\n\t\t\t\t\tconst formattedExpression: string = expressionFormatter(innerElement, position);\r\n\t\t\t\t\tformattedSentence = formattedSentence + formattedExpression + \",\";\r\n\t\t\t\t} else if (innerElement.match(Regexes.wordMarker)) {\r\n\t\t\t\t\tconst ListOfWords: string = sentenceIntoWordList(innerElement.trim());\r\n\t\t\t\t\tformattedSentence = formattedSentence + ListOfWords + \",\";\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (formattedSentence.match(Regexes.wordEndsWithComma)) {\r\n\t\t\t\tformattedSentence = formattedSentence.slice(0, formattedSentence.length - 1);\r\n\t\t\t}\r\n\t\t\tformattedText.push([formattedSentence]);\r\n\t\t} else if (element.match(Regexes.wordMarker)) {\r\n\t\t\tconst ListOfWords: string = sentenceIntoWordList(element.trim());\r\n\t\t\tformattedText.push([ListOfWords]);\r\n\t\t}\r\n\t\tposition = position + element.length;\r\n\t});\r\n\tconst output = formattedTextIntoString(formattedText);\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * format the words from a sentence-string into a list of words\r\n * @param input string including words\r\n * @return a string[] where each element is one word\r\n */\r\nexport function sentenceIntoWordList(input: string): string {\r\n\tconst splittedSentenceIntoListOfWords = input.split(Regexes.wordSeparator);\r\n\tconst listOfWords: string[] = [];\r\n\tfor (let index = 0; index < splittedSentenceIntoListOfWords.length; index++) {\r\n\t\tif (splittedSentenceIntoListOfWords[index].trim() === \"\") {\r\n\t\t\tsplittedSentenceIntoListOfWords.splice(index, 1);\r\n\t\t} else {\r\n\t\t\tlistOfWords.push(splittedSentenceIntoListOfWords[index].trim());\r\n\t\t}\r\n\t}\r\n\tlet listOfWordsString = \"\";\r\n\tlistOfWords.forEach(element => {\r\n\t\tlistOfWordsString = listOfWordsString + element + \",\";\r\n\t});\r\n\tif (listOfWordsString.match(Regexes.wordEndsWithComma)) {\r\n\t\tlistOfWordsString = listOfWordsString.slice(0, listOfWordsString.length - 1);\r\n\t}\r\n\r\n\treturn listOfWordsString;\r\n}\r\n\r\n/**\r\n * Returns a string which consists of the formatted text.\r\n */\r\nexport function formattedTextIntoString(formattedText: string[][]): string {\r\n\tlet output = \"[\";\r\n\tformattedText.forEach(element => {\r\n\t\toutput = output + \"[\";\r\n\t\telement.forEach(innerElement => {\r\n\t\t\tinnerElement = innerElement.toLowerCase();\r\n\t\t\tif (innerElement.match(Regexes.bracketLeft)) {\r\n\t\t\t\toutput = output + innerElement;\r\n\t\t\t} else if (innerElement.match(Regexes.bracketRight)) {\r\n\t\t\t\tif (output.match(Regexes.wordEndsWithComma)) {\r\n\t\t\t\t\toutput = output.slice(0, output.length - 1);\r\n\t\t\t\t}\r\n\t\t\t\toutput = output + innerElement + \",\";\r\n\t\t\t} else {\r\n\t\t\t\toutput = output + innerElement + \",\";\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (output.match(Regexes.wordEndsWithComma)) {\r\n\t\t\toutput = output.slice(0, output.length - 1);\r\n\t\t}\r\n\t\toutput = output + \"],\";\r\n\t});\r\n\tif (output.match(Regexes.wordEndsWithComma)) {\r\n\t\toutput = output.slice(0, output.length - 1);\r\n\t}\r\n\toutput = output + \"]\";\r\n\r\n\treturn output;\r\n}\r\n","import Issue from \"../issueHandling/issue\";\r\nimport { addIssue } from \"../issueHandling/issueMapping\";\r\nimport issueJson from \"../issueHandling/knownIssues.json\";\r\nimport json from \"./allowedVocab.json\";\r\nimport uniqueValues from \"./iterators\";\r\n\r\n/**\r\n * Regular expression that looks for any and all words. A word is defined as some sequence of\r\n * characters (\\w+) between wordbarriers (\\b).\r\n */\r\nexport const anyWord = new RegExp(/\\b\\w+\\b/g);\r\n/**\r\n * Predefined dictionary containing all allowed Words\r\n */\r\nconst allowedWords = json;\r\nexport interface Position { fromIndex: number; toIndex: number; }\r\n\r\n/**\r\n * Adds an Issue for every invalid word in a given text.\r\n * @param text the user-input\r\n */\r\nexport function collectInvalidWordsInIssues(text: string): void {\r\n\tconst temp = text.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, \" \");\r\n\tconst invalidWords = getInvalidWords(temp);\r\n\tfor (const word of invalidWords) {\r\n\t\tif (!(allowedWords.includes(word.toLowerCase()))) {\r\n\t\t\tconst allPositionsOfInvalidWord = getPositionsOfInvalidWord(word, temp);\r\n\t\t\tfor (const pos of allPositionsOfInvalidWord) {\r\n\t\t\t\taddIssue(\"INVALID_WORD\", pos, {word});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Creates a Array of each occurence of a given word in a text.\r\n * @param invalidWord - A word that is not listed in allowedVocab.json\r\n * @param text - the userinput\r\n */\r\nfunction getPositionsOfInvalidWord(invalidWord: string, text: string): Position[] {\r\n\tconst result: Position[] = [];\r\n\tlet offSet: number = 0;\r\n\r\n\tlet foundIndex: number;\r\n\ttext = \" \" + text + \" \";\r\n\twhile ((foundIndex = text.indexOf(\" \" + invalidWord + \" \", offSet)) !== -1) {\r\n\toffSet = foundIndex + 1;\r\n\tresult.push({\r\n\t\t\tfromIndex: foundIndex,\r\n\t\t\ttoIndex: foundIndex + invalidWord.length - 1,\r\n\t\t});\r\n\t}\r\n return result;\r\n}\r\n\r\n/**\r\n * Bundling the functionalities of collectAllInvalidWords and removeDuplicates.\r\n * @returns a Stringarray containing exactly one copy of each wrong word in a text.\r\n */\r\nexport function getInvalidWords(text: string): string[] {\r\n\treturn removeDuplicates(collectAllInvalidWords(text));\r\n}\r\n\r\n/**\r\n * Collects all words that are invalid in the text.\r\n * @param text - the userinput\r\n */\r\nfunction collectAllInvalidWords(text: string): string[] {\r\n\tconst words = text.match(anyWord) || [];\r\n\treturn words.filter(word => !(allowedWords.includes(word.toLowerCase())));\r\n}\r\n\r\nfunction removeDuplicates<T>(invalidWords: T[]): T[] {\r\n\treturn Array.from(uniqueValues(invalidWords));\r\n}\r\n\r\n/**\r\n * The next three functions print a Message for every occurence of every invalid word.\r\n */\r\n\r\nexport function logMultipleWords(words: string[], positions: Position[]): Issue[][] {\r\n\treturn words.map(word => logMultipleOccurences(word, positions));\r\n}\r\n\r\nfunction logMultipleOccurences(word: string, position: Position[]): Issue[] {\r\n\treturn position.map(pos => logSingleWord(word, pos));\r\n}\r\n\r\n/**\r\n * Creates an Issue for a single word.\r\n * @param word - a word that is invalid\r\n * @param position - the position of the word\r\n */\r\nexport function logSingleWord(word: string, position: Position): Issue {\r\n\treturn {\r\n\t\tmessage: `${word} von Stelle ${position.fromIndex} bis ${position.toIndex} ist ein unerlaubtes Wort! \\n`,\r\n\t\tposition: {\r\n\t\t\tfromIndex: position.fromIndex,\r\n\t\t\ttoIndex: position.toIndex,\r\n\t\t},\r\n\t\tseverity: issueJson.INVALID_WORD.severity,\r\n\t\tcode: issueJson.INVALID_WORD.message,\r\n\t};\r\n}\r\n","/**\r\n * Creates a new version of an iterable values without duplicated\r\n */\r\nexport default function uniqueValues<T>(values: Iterable<T>): Iterable<T> {\r\n\treturn new Set(values);\r\n}\r\n","import { textFormatter } from \"../inputFormatter/textFormatter\";\r\nimport { getDiprocheResponse } from \"../proofChecker\";\r\nimport { collectInvalidWordsInIssues } from \"../vocabularyChecker/detectWrongSyntax\";\r\nimport { addDiprocheIssues } from \"./diprocheResponseProcessing\";\r\n\r\nexport enum Mode {\r\n\tpropositionalLogic = \"diproche\",\r\n\tfirstOrderPredicateLogic = \"diproche_fo\",\r\n\ttest = \"teste\",\r\n}\r\n\r\n/**\r\n * returns a string containing the userInput as an argument of a predicate\r\n * @param userInput - the user input\r\n * @param mode - the mode\r\n */\r\nexport function addPredicate(userInput: string, mode: Mode) {\r\n\treturn mode + \"(\" + userInput + \").\";\r\n}\r\n\r\n/**\r\n * collects all vocabErrors\r\n */\r\nexport function getVocabErrors(userInput: string): void {\r\n\tcollectInvalidWordsInIssues(userInput);\r\n}\r\n\r\n/**\r\n * collects all vocabErrors and should also collect grammatical errors\r\n */\r\nexport function getSyntacticErrors(userInput: string) {\r\n\tgetVocabErrors(userInput);\r\n}\r\n\r\n/**\r\n * Collects all errors before the execution of diproche\r\n */\r\nexport function getErrorsBeforeDiproche(userInput: string) {\r\n\tgetSyntacticErrors(userInput);\r\n\t// getSemanticErrors(userInput);\r\n}\r\n\r\n/**\r\n * Collects all errors that diproche returns\r\n */\r\nexport async function getErrorsAfterDiproche(diprocheInput: string): Promise<void> {\r\n\tconst response: string = await getDiprocheResponse(diprocheInput);\r\n\taddDiprocheIssues(response);\r\n}\r\n\r\n/**\r\n * this function collects all Errors.\r\n */\r\nexport async function createErrors(userinput: string): Promise<void> {\r\n\tgetErrorsBeforeDiproche(userinput);\r\n\r\n\t// Also adds Issues which are caused when progressing this function\r\n\tconst diprocheInput = textFormatter(userinput) + \".\";\r\n\tawait getErrorsAfterDiproche(diprocheInput);\r\n}\r\n","import * as _ from \"lodash\";\r\nimport { addIssue } from \"../issueHandling/issueMapping\";\r\n\r\n/**\r\n * collects the response from Diproche\r\n * @param diprocheResponse - a string containing the response from diproche within prolog\r\n */\r\nexport function addDiprocheIssues(diprocheResponse: string): void {\r\n\tconst errorList = convertErrorListStringToJSArray(getErrorList(diprocheResponse));\r\n\terrorList[0].forEach((unverifiedLine: number) => {\r\n\t\taddIssue(\"UNVERIFIED_LINE\", {\r\n\t\t\tfromIndex: unverifiedLine,\r\n\t\t\ttoIndex: unverifiedLine,\r\n\t\t});\r\n\t});\r\n}\r\n\r\nfunction convertErrorListStringToJSArray(listAsString: string): number[][] {\r\n\tlet stringCopy: string = listAsString;\r\n\r\n\t// Removing the outter brackets\r\n\tstringCopy = stringCopy.slice(1);\r\n\tstringCopy = stringCopy.slice(0, stringCopy.length - 1);\r\n\r\n\tconst outterForm: string[] = stringCopy.split(\",\");\r\n\tconst jsArray: number[][] = [];\r\n\r\n\toutterForm.forEach((innerString: string) => {\r\n\t\tinnerString = innerString.slice(1);\r\n\t\tinnerString = innerString.slice(0, innerString.length - 1);\r\n\r\n\t\tconst innerArray: string[] | undefined = innerString.split(\",\");\r\n\r\n\t\tif (!innerArray || _.isEqual(innerArray, new Array(\"\"))) {\r\n\t\t\tjsArray.push(new Array());\r\n\t\t} else {\r\n\t\t\tinnerArray.forEach((element: string) => jsArray.push([parseInt(element, 10)]));\r\n\t\t}\r\n\t});\r\n\r\n\treturn jsArray;\r\n}\r\n\r\nfunction getErrorList(diprocheResponse: string): string {\r\n\tconst fetchErrorListRegExp = /List of Lists with unverified Input: ([^$]*)/;\r\n\tconst ErrorList: RegExpExecArray | null = fetchErrorListRegExp.exec(diprocheResponse);\r\n\tif (ErrorList) {\r\n\t\treturn ErrorList[1];\r\n\t}\r\n\r\n\t// Pretending no error happened.\r\n\t// This part of the code will be reached if the diproche server is not running or the list ist not diproche readable\r\n\t// (wrong syntax or unallowed words)\r\n\treturn \"[]\";\r\n\r\n}\r\n","import { createErrors } from \"./diproche/diprocheInterface\";\r\nimport Issue from \"./issueHandling/issue\";\r\nimport { emptyIssueList, listAllIssues } from \"./issueHandling/issueMapping\";\r\n\r\n// Ordered by their degree of fatality\r\nconst severities: string[] = [\"FATALERROR\", \"ERROR\", \"WARNING\", \"HINT\"];\r\n\r\n/**\r\n\t* Checks the userinput and returns the Issues it caused\r\n\t* @param userInput - The user input\r\n\t* @return The syntatical, sementatical and technical issues for the given user input\r\n\t*/\r\nexport async function checkProof(userInput: string): Promise<readonly Issue[]> {\r\n\temptyIssueList();\r\n\tconst curatedUserInput: string = userInput.replace(/\\n/g, \" \");\r\n\tawait createErrors(curatedUserInput);\r\n\treturn orderIssuesBySeverity(listAllIssues());\r\n}\r\n\r\n/**\r\n\t* Receives the diproche response for a given input\r\n\t* @param userInput - The user input as a list which should end with a \".\"\r\n\t* @return The diproche reponse\r\n\t*/\r\nexport async function getDiprocheResponse(userInput: string): Promise<string> {\r\n\r\n\tconst body = userInput;\r\n\r\n\tconst response = await fetch(\"http://localhost:3000/dipr\", {\r\n\t\theaders: {\r\n\t\t\t\"Content-Type\": \"application/x-prolog\",\r\n\t\t},\r\n\t\tmethod: \"POST\",\r\n\t\tbody,\r\n\t});\r\n\r\n\tconst responseText = await response.text();\r\n\treturn responseText;\r\n}\r\n\r\n/**\r\n\t* Returns a given issue array in the order of the the issue's fatality (most fatal first)\r\n\t* @param issues - The Issue Array to be ordered\r\n\t* @return The ordered Issue Array\r\n\t*/\r\nfunction orderIssuesBySeverity(issues: readonly Issue[]): readonly Issue[] {\r\n\r\n\tlet orderedIssues: Issue[] = [];\r\n\r\n\t// Adds Issues by their severity in the order of constant severities\r\n\tseverities.forEach((severity: string) => {\r\n\t\torderedIssues = orderedIssues.concat(\r\n\t\t\tissues.filter((singleIssue: Issue) => singleIssue.severity === severity),\r\n\t\t);\r\n\t});\r\n\r\n\treturn orderedIssues;\r\n}\r\n","import React from \"react\";\r\nimport Position from \"../../util/issueHandling/position\";\r\n\r\nexport interface Props {\r\n\tposition: Position;\r\n}\r\n\r\nexport class IssuePositionInformation extends React.Component<Props> {\r\n\r\n\tpublic render() {\r\n\t\treturn <div>\r\n\t\t\t{\" Von Index \" + this.props.position.fromIndex + \" bis \" + this.props.position.toIndex}\r\n\t\t</div>;\r\n\r\n\t}\r\n}\r\n\r\nexport default IssuePositionInformation;\r\n","import React from \"react\";\r\nimport shortid from \"shortid\";\r\nimport Issue from \"../../util/issueHandling/issue\";\r\nimport IssuePositionInformation from \"./issuePositionInformation\";\r\n\r\nexport interface Props {\r\n\tissue: Issue;\r\n}\r\n\r\nexport class IssueInformation extends React.Component<Props, {}> {\r\n\r\n\tpublic render() {\r\n\r\n\t\tlet displayedPosition: any = \"\";\r\n\t\tconst position = this.props.issue.position;\r\n\t\tif (position) {\r\n\t\t\tdisplayedPosition =\r\n\t\t\t\t<IssuePositionInformation\r\n\t\t\t\tkey={shortid.generate()}\r\n\t\t\t\tposition={position!}\r\n\t\t\t/>;\r\n\t\t}\r\n\r\n\t\treturn <div>\r\n\t\t\t{this.props.issue.message} {displayedPosition}\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default IssueInformation;\r\n","import \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport React from \"react\";\r\nimport Issue from \"../../util/issueHandling/issue\";\r\nimport { addIssue, emptyIssueList, listAllIssues} from \"../../util/issueHandling/issueMapping\";\r\nimport { checkProof } from \"../../util/proofChecker\";\r\nimport exerciseStyles from \"../exercises/exercises.module.scss\";\r\nimport buttonStyles from \"../generalStyles/buttons.module.scss\";\r\nimport IssueInformation from \"./issueInformation\";\r\nimport styles from \"./proofEditor.module.scss\";\r\n\r\nconst textboxPlaceHolder = \"Gebe hier deinen Beweis ein...\";\r\n\r\n/** The parent component needs to control the proofEditor and have these states */\r\nexport interface IParentState {\r\n\tissues: Issue[];\r\n\tuserInput: string;\r\n}\r\n\r\ninterface IProps extends IParentState {\r\n\t// To squeeze in text inbetween the button and the input field\r\n\tdisplayAfterInputfield?: string | JSX.Element;\r\n\ttransformUserinputPreCheck?(userInput: string): string;\r\n\tsetStateParent(newState: object): void;\r\n}\r\n\r\nclass ProofEditor extends React.Component<IProps, {}> {\r\n\r\n\tpublic constructor(props: IProps) {\r\n\t\tsuper(props);\r\n\r\n\t\t// If the initial issue given is empty it will update it to contain the empty issue\r\n\t\t// This is an indication that the proof checker hasn't been used yet and therefore\r\n\t\t// not show the success message\r\n\t\tif (this.props.issues.length === 0) {\r\n\t\t\temptyIssueList();\r\n\t\t\taddIssue(\"EMPTY_ISSUE\");\r\n\t\t\tthis.props.setStateParent({issues: listAllIssues()});\r\n\t\t}\r\n\t}\r\n\r\n\tpublic render() {\r\n\t\treturn <div className={styles.proofEditor}>\r\n\r\n\t\t\t<textarea\r\n\t\t\t\tclassName={styles.textInput}\r\n\t\t\t\tplaceholder={textboxPlaceHolder}\r\n\t\t\t\trequired={true}\r\n\t\t\t\tvalue={this.props.userInput}\r\n\t\t\t\tonChange={ev => this.props.setStateParent({userInput: ev.target.value})}\r\n\t\t\t/>\r\n\r\n\t\t\t{this.renderAfterInputFieldText()}\r\n\r\n\t\t\t<br />\r\n\r\n\t\t\t<button className={buttonStyles.buttons + \" \" + styles.checkProofBtn}\r\n\t\t\t\tonClick={() => this.checkInput()}>\r\n\t\t\t\tPrüfen\r\n\t\t\t</button>\r\n\r\n\t\t\t<div className={styles.issuesInformation}>\r\n\t\t\t\t{this.renderIssueList()}\r\n\t\t\t</div>\r\n\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n\t// An attempt to make this inline didn't work\r\n\tprivate renderAfterInputFieldText(): string | JSX.Element {\r\n\t\tif (this.props.displayAfterInputfield) {\r\n\t\t\treturn  <div className={exerciseStyles.postText}>\r\n\t\t\t\t<br />\r\n\t\t\t\t{this.props.displayAfterInputfield}s\r\n\t\t\t</div>;\r\n\t\t}\r\n\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tprivate readonly checkInput = async (): Promise<void> => {\r\n\t\tlet userInput = this.props.userInput;\r\n\t\tif (this.props.transformUserinputPreCheck) {\r\n\t\t\tuserInput = this.props.transformUserinputPreCheck(userInput);\r\n\t\t}\r\n\r\n\t\tconst issues: readonly Issue[] = await checkProof(userInput);\r\n\t\tthis.props.setStateParent({ issues });\r\n\t}\r\n\r\n\tprivate renderIssueList(): JSX.Element | JSX.Element[] {\r\n\t\tif (this.props.issues.length === 0) {\r\n\t\t\treturn <div\r\n\t\t\t\t\tclassName={styles.successMessage}\r\n\t\t\t\t>\r\n\t\t\t\tAlles richtig\r\n\t\t\t\t</div>;\r\n\t\t}\r\n\r\n\t\tconst issueList: JSX.Element[] = [];\r\n\r\n\t\tthis.props.issues.map((issue: Issue) => {\r\n\t\t\tissueList.push(<IssueInformation\r\n\t\t\t\tissue={issue}\r\n\t\t\t/>);\r\n\t\t});\r\n\r\n\t\treturn issueList;\r\n\t}\r\n}\r\n\r\nexport default ProofEditor;\r\n","import React from \"react\";\r\nimport SingleExampleDisplay from \"../examples/singleExampleDisplay\";\r\nimport buttonStyles from \"../generalStyles/buttons.module.scss\";\r\nimport ProofEditor,  { IParentState } from \"../proofEditor/proofEditor\";\r\nimport styles from \"./exercises.module.scss\";\r\n\r\ninterface IExercise {\r\n\ttitle: string;\r\n\tstart: string;\r\n\tend: string;\r\n\texampleSolution: string[][]; // More accurately: Arrray<[string, string]> but will cause type issues\r\n}\r\n\r\ninterface IState extends IParentState {\r\n\texerciseID: number;\r\n\t// A potential solution that is.\r\n\tshowSolution: boolean;\r\n}\r\n\r\ninterface IProps {\r\n\tdata: IExercise[];\r\n}\r\n\r\nclass Exercises extends React.Component<IProps, IState> {\r\n\r\n\tpublic state = {\r\n\t\tuserInput: \"\",\r\n\t\tissues: [],\r\n\t\texerciseID: -1,\r\n\t\tshowSolution: false,\r\n\t};\r\n\r\n\tpublic render() {\r\n\t\treturn <div>\r\n\t\t\t<select\r\n\t\t\t\tonChange={(event) => this.selectorOnChangeHandler(event)}\r\n\t\t\t\tclassName={styles.selector}\r\n\t\t\t>\r\n\t\t\t\t<option value={-1}>Bitte wähle eine Übung</option>\r\n\t\t\t\t{this.renderExerciseOptions()}\r\n\t\t\t</select>\r\n\t\t\t{this.renderExerciseOrSolution()}\r\n\t\t\t{this.renderToggleButton()}\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n\tprivate selectorOnChangeHandler(event: React.ChangeEvent<HTMLSelectElement>): void {\r\n\t\tthis.setState({exerciseID: Number.parseInt(event.target.value, 10)});\r\n\t}\r\n\r\n\tprivate renderExerciseOrSolution(): JSX.Element {\r\n\t\t// Could be made more general, but -1 is the default \"no exercise is selected\" and otherwise it should be an error\r\n\t\t// More general could be: if(!exercises[this.state.exerciseID])\r\n\t\t// It will then create an empty return if the exercise at the index doesn't exist\r\n\t\tif (this.state.exerciseID === -1) {\r\n\t\t\t// Returns nothing but is still a JSX.Element\r\n\t\t\treturn <React.Fragment></React.Fragment>;\r\n\t\t}\r\n\r\n\t\tif (this.state.showSolution) {\r\n\t\t\treturn <SingleExampleDisplay\r\n\t\t\t\texampleData = { this.props.data[this.state.exerciseID].exampleSolution }\r\n\t\t\t/>;\r\n\t\t}\r\n\r\n\t\tconst activeExercise = this.props.data[this.state.exerciseID];\r\n\t\treturn <div>\r\n\t\t\t<div className={styles.preText}>\r\n\t\t\t\t{activeExercise.start} <br />\r\n\t\t\t</div>\r\n\t\t\t<ProofEditor\r\n\t\t\t\tuserInput = {this.state.userInput}\r\n\t\t\t\tissues = {this.state.issues}\r\n\t\t\t\tsetStateParent = {(insert) => this.setState(insert)}\r\n\t\t\t\ttransformUserinputPreCheck={(input: string) => this.addStartAndEndToUserInput(input)}\r\n\t\t\t\tdisplayAfterInputfield={activeExercise.end}\r\n\t\t\t/>\r\n\t\t\t<br />\r\n\t\t</div>;\r\n\t}\r\n\r\n\tprivate  addStartAndEndToUserInput(userInput: string): string {\r\n\r\n\t\tconst activeExercise = this.props.data[this.state.exerciseID];\r\n\t\tconst modifiedUserInput: string =  activeExercise.start\r\n\t\t\t+ \"\\n\" + userInput\r\n\t\t\t+ \"\\n\" + activeExercise.end;\r\n\r\n\t\treturn modifiedUserInput;\r\n\t}\r\n\r\n\tprivate renderToggleButton(): JSX.Element {\r\n\t\tif (this.state.exerciseID === -1) {\r\n\t\t\treturn <React.Fragment></React.Fragment>;\r\n\t\t}\r\n\r\n\t\tlet buttonCaption: string = \"Musterlösung anzeigen\";\r\n\r\n\t\tif (this.state.showSolution) {\r\n\t\t\tbuttonCaption = \"Zurück zum Editor\";\r\n\t\t}\r\n\r\n\t\treturn <button\r\n\t\t\tclassName={buttonStyles.buttons + \" \" + styles.toggleExerciseSolutionBtn}\r\n\t\t\tonClick={() => this.setState({showSolution: !this.state.showSolution})}\r\n\t\t>\r\n\t\t\t{buttonCaption}\r\n\t\t</button>;\r\n\t}\r\n\r\n\tprivate renderExerciseOptions(): JSX.Element[] {\r\n\t\tconst options: JSX.Element[] = [];\r\n\t\tthis.props.data.forEach((oneExercise, index) => {\r\n\t\t\toptions.push(<option value={index}>\r\n\t\t\t\t{oneExercise.title}\r\n\t\t\t</option>);\r\n\t\t});\r\n\r\n\t\treturn options;\r\n\t}\r\n\r\n}\r\n\r\nexport default Exercises;\r\n","import React from \"react\";\r\nimport ExerciseTemplate from \"../exercises/exercises\";\r\nimport exerciseData from \"./exercises.json\";\r\n\r\nconst Exercises = () => {\r\n\treturn <ExerciseTemplate\r\n\t\tdata={exerciseData.exercises}\r\n\t/>;\r\n};\r\n\r\nexport default Exercises;\r\n","import React from \"react\";\r\nimport ProofEditor, { IParentState } from \"../proofEditor/proofEditor\";\r\n\r\nclass Sandbox extends React.Component< {}, IParentState > {\r\n\r\n\tpublic state: IParentState =  {\r\n\t\tuserInput: \"\",\r\n\t\tissues:  [],\r\n\t};\r\n\r\n\tpublic render() {\r\n\t\treturn <React.Fragment>\r\n\t\t\t<ProofEditor\r\n\t\t\t\tuserInput = {this.state.userInput}\r\n\t\t\t\tissues = {this.state.issues}\r\n\t\t\t\tsetStateParent = {(input) => this.setState(input)}\r\n\t\t\t/ >\r\n\t\t</React.Fragment>;\r\n\t}\r\n\r\n}\r\n\r\nexport default Sandbox;\r\n","import React from \"react\";\r\nimport styles from \"./wiki.module.scss\";\r\n\r\nclass WikiPropositionalLogic extends React.Component {\r\n\r\n\tpublic render() {\r\n\t\treturn <div className={styles.site}>\r\n\t\t\t<h1>Allgemeines</h1>\r\n\t\t\t<p>Die Objekte, die man in der Aussagenlogik untersucht,\r\n\t\t\t\tsind <b>Aussagen</b>, welche mit sogenannten Junktoren verknüpft werden.\r\n\t\t\t\tDabei geht man von elementaren Aussagen aus. Sogenannten\r\n\t\t\t\tAtomen.</p>\r\n\t\t\t\t<h2>Atome</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tAtome werden meist mit A, B, C, ..., Z\r\n\t\t\t\t\tgekennzeichnet. Jedem Atom kann einen Wahrheitswert zugeordnet werden.\r\n\t\t\t\t\tWir betrachten ausschließlich die Wahrheitswerte \"wahr\" und \"falsch\".\r\n\t\t\t\t\tAtome heißen auch \"atomare Formeln\".</p>\r\n\t\t\t\t\t<h2>Nicht-atomare Formeln</h2>\r\n\t\t\t\t\t<p>Atomare Formeln können mit den Junktoren\r\n\t\t\t\t\t&#172; (nicht), &amp; (und), | (oder), &rarr; (Implikation) und &harr; (Äquivalenz).\r\n\t\t\t\t\t&#172; negiert den Wahrheitswert einer Formel. Das heißt eine wahre Formel wird falsch\r\n\t\t\t\t\tund eine falsche Formel wird wahr. Statt &amp; sieht man normalerweise\r\n\t\t\t\t\tdas Zeichen &#8743; und statt | das Zeichen &#8744;. Auf einer gewöhnlichen Tastatur\r\n\t\t\t\t\tgibt es diese Zeichen jedoch nicht. Daher benutzen wir in Diproche lieber die ersten\r\n\t\t\t\t\tbeiden Zeichen. Alternativ kann man auch die Worte \"und\" und \"oder\" schreiben.\r\n\t\t\t\t\t&#172; ist der einzige Junktor, der nur auf einer statt auf zwei Formeln operiert.\r\n\t\t\t\t\tWenn A und B Formeln sind, dann ist A&amp;B wahr genau dann, wenn\r\n\t\t\t\t\tsowohl A, als auch B wahr ist. Ansonsten ist A&amp;B falsch.\r\n\t\t\t\t\tA | B ist wahr genau dann, wenn mindestens eine der Formeln\r\n\t\t\t\t\tA und B wahr ist. Ansonsten ist A | B falsch.\r\n\t\t\t\t\tA&rarr;B ist wahr genau dann, wenn entweder die Voraussetzung A\r\n\t\t\t\t\tfalsch ist oder A und B wahr sind. Ansonsten ist A&rarr;B falsch.\r\n\t\t\t\t\tA&harr;B ist wahr genau dann, wenn A und B beide falsch oder beide\r\n\t\t\t\t\twahr sind. Ansonsten ist A&harr;B falsch.\r\n\t\t\t\t</p>\r\n\t\t\t\t<h2>Klassifikation einiger Formeln</h2>\r\n\t\t\t\t<p> Sei F eine Formel mit n Aussagenvariablen. Man kann allen Aussagenvariablen\r\n\t\t\t\t\tvon F auf 2<sup>n</sup> verschiedene Weisen einen Wahrheitswert zuordnen.\r\n\t\t\t\t\tF heißt nun <b>allgemeingültig</b> oder auch <b>Tautologie</b>, falls jede Wertebelegung F wahr macht.\r\n\t\t\t\t\tGibt es mindestens eine Wahrheitswertebelegung, sodass F wahr wird, so heißt\r\n\t\t\t\t\tF <b>erfüllbar</b>. Gibt es keine solche Wahrheitswertebelegung, dann heißt F <b>unerfüllbar</b> oder\r\n\t\t\t\t\t auch <b>Kontradiktion</b>.\r\n\t\t\t\t</p>\r\n\t\t\t\t<h2>Was ist ein Beweis?</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tWenn man etwas beweisen muss, so handelt es sich immer um eine Aussage.\r\n\t\t\t\t\tWir nennen die zu zeigende Aussage Z. Eventuell gibt es auch einige Annahmen\r\n\t\t\t\t\tdie man treffen kann. Diese können auch als Aussage gesehen werden. Wir nennen\r\n\t\t\t\t\tsie A. Dann besteht ein Beweis von Z daraus, Formeln zu finden, sagen wir B,..., Y,\r\n\t\t\t\t\tsodass A&rarr;B&rarr;...&rarr;Y&rarr;Z eine allgemeingültige Formel ist. Es muss also eine\r\n\t\t\t\t\tAbfolge von Schlussfolgerungen gefunden werden, die in jedem Fall wahr ist. Streng genommen\r\n\t\t\t\t\tkönnen in allen Aussagen auch \"quantifizierte\" Variablen auftauchen. Dies wird aber erst\r\n\t\t\t\t\tzu einem späteren Zeitpunkt behandelt.\r\n\t\t\t\t</p>\r\n\t\t\t\t<h2>Literatur</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tÜber die Unibibliothek gibt es zu dem Thema folgende\r\n\t\t\t\t\tBücher gratis als E-Book-Download:\r\n\t\t\t\t</p>\r\n\t\t\t\t<p>Martin Ziegler - Mathematische Logik, 2017, 2. Auflage</p>\r\n\t\t\t\t<p>Kurt-Ulrich Witt - Mathematische Grundlagen für die Informatik, 2013</p>\r\n\t\t</div>;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default WikiPropositionalLogic;\r\n","// tslint:disable:file-name-casing\r\nimport React, { Component } from \"react\";\r\nimport { BrowserRouter, Route, Switch } from \"react-router-dom\";\r\nimport styles from \"./generalStyles/pageLayout.module.scss\";\r\n\r\n// tslint:disable: ordered-imports\r\nimport MainPage from \"./mainPage/mainPage\";\r\nimport Navigation from \"./navigationBar/navigationBar\";\r\nimport Kontakt from \"./contact/contact\";\r\nimport ErrorPage404 from \"./errorPage404/errorPage404\";\r\n\r\nimport ExamplesPropositionalLogic from \"./propositionalLogic/examplePage\";\r\nimport ExercisesPropositionalLogic from \"./propositionalLogic/exercises\";\r\nimport SandboxPropositionalLogic from \"./propositionalLogic/sandbox\";\r\nimport WikiPropositionalLogic from \"./propositionalLogic/wiki\";\r\n// tslint:enable: ordered-imports\r\n\r\nclass App extends Component<{}, {}> {\r\n\tpublic render() {\r\n\r\n\t\treturn (\r\n\t\t\t<BrowserRouter>\r\n\t\t\t\t<React.Fragment>\r\n\t\t\t\t\t<Navigation />\r\n\t\t\t\t\t<div className={styles.pageContent}>\r\n\t\t\t\t\t\t<Switch>\r\n\r\n\t\t\t\t\t\t\t<Route exact path=\"/\" component={MainPage} />\r\n\t\t\t\t\t\t\t<Route exact path=\"/examples\" component={ExamplesPropositionalLogic} />\r\n\t\t\t\t\t\t\t<Route exact path=\"/exercises\" component={ExercisesPropositionalLogic} />\r\n\t\t\t\t\t\t\t<Route exact path=\"/sandbox\" component={SandboxPropositionalLogic} />\r\n\t\t\t\t\t\t\t<Route exact path=\"/wiki\" component={WikiPropositionalLogic} />\r\n\t\t\t\t\t\t\t<Route exact path=\"/contact\" component={Kontakt} />\r\n\t\t\t\t\t\t\t<Route component={ErrorPage404} />\r\n\r\n\t\t\t\t\t\t</Switch>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</React.Fragment>\r\n\t\t\t</BrowserRouter>\r\n\t\t);\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./components/App\";\r\nimport \"./index.scss\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// if you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}